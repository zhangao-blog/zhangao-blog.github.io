---
layout:     post
title:      0812算法 - 动态规划08
subtitle:   121. 买卖股票的最佳时机 | 122. 买卖股票的最佳时机 II | 123. 买卖股票的最佳时机 III
date:       2024-08-12
author:     ZA
header-img: img/algorithm.png
catalog: true
tags:
    - 算法记录
    - 动态规划
---

## [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

> <pre><strong>输入：</strong>[7,1,5,3,6,4]
> <strong>输出：</strong>5
> <strong>解释：</strong>在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
> 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</pre>

### 思路

对于股票买卖，任意一天只能是两种形式：1.持有（买入、持有）；2.未持有（观望、卖出）

1. **dp数组及其下标含义**：对于两种状态
   1. dp[i][0]：持有股票下，第 i 天的最大资金
   2. dp[i][1]：未持有股票下，第 i 天的最大资金
2. **递推公式**：同理，两个形式各自可由两种状态推出
   1. 持有股票dp[i][0]时：
      1. 昨天(i-1)就已经持有股票，那么保持现状资金=`dp[i-1][0]`
      2. 今天(i)才买入股票，那么资金就是买入后的`-prices[i]`
      3. 因此应选择资金最多的`dp[i][0] = max(dp[i-1][0], -price[i]`
   2. 未持有股票dp[i][1]时：
      1. 昨天(i-1)就未持有股票，那么保持现状资金=`dp[i-1][1]`
      2. 今天(i)才卖出股票，那么资金就是卖出后的`prices[i] + dp[i - 1][0]`
      3. 因此应选择资金最多的`dp[i][1] = max(dp[i-1][1], prices[i] + dp[i - 1][0]`
   3. PS：肯定只能先买入才能带成本卖出，因此买入和卖出的dp公式不同
3. **数组初始化**：根据两个递推公式，取决于dp[0][1]和dp[0][0]
   1. dp[0][0]：第0天持有股票，只能当天买入，因此 = `-price[0]`
   2. dp[0][1]：第0天不持有股票，那就是资金为0
4. **遍历顺序**：dp[i]由dp[i-1]推导，一定是从前向后遍历
5. **举例推导**：以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：
   ![](https://s3.bmp.ovh/imgs/2024/08/27/73f943586ee2516c.png)

> 最终结果的最大收益一定是dp[5][1]，因为本题还没有考虑其他手续费，股票再便宜也是卖了比不卖强

### 代码实现

```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size()==0) return 0;

        // 定义与初始化
        vector<vector<int>>dp(prices.size(), vector<int>(2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        // 迭代体
        for(int i=1; i<prices.size(); i++){
            dp[i][0] = max(dp[i-1][0], -prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]);
        }

        // 返回最大值
        return dp[prices.size()-1][1];
    }
};
```

## [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

**示例 1：**

> <pre><strong>输入：</strong>prices = [7,1,5,3,6,4]
> <strong>输出：</strong>7
> <strong>解释：</strong>在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
> 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
> 最大总利润为 4 + 3 = 7 。</pre>

### 思路

**自本题开始，股票可以买卖多次了！但仍只有一支股票。**
唯一的区别反映在当天持有买入的时候，由于之前只能买卖一次，唯一的买入必在唯一的卖出之前，因此无需记录买入之前的资金情况，而卖出是始终需要考虑的

1. **dp数组及其下标含义**：同样分为持股资金`dp[i][0]`和未持股资金`dp[i][1]`
2. **递推公式**：与上题唯一的区别出现在此处：
   1. 持有股票dp[i][0]时：
      1. 若为之前持有，则资金不变为 dp[i-1][0]
      2. 若为今日买入，那就需要考虑之前是否已经买卖过而产生了成本prices[i]以外的资金变化，为`dp[i-1][1]-price[i]`
      3. 此时持有股票下的递推公式变为 `dp[i][0] = max(dp[i-1][0], dp[i - 1][1] - prices[i]`
   2. 未持有股票时逻辑不变，为`dp[i][1] = max(dp[i-1][1], dp[i - 1][0] + prices[i]`
3. **数组初始化**：同`dp[0][0] = -prices[i];` `dp[0][1] = 0;`
4. **遍历顺序**：同为从前向后遍历

### 代码实现

```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int size = prices.size();
        
        vector<vector<int>>dp(size, vector<int>(2));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for(int i=1; i<size; i++){
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]);
        }

        return dp[size-1][1];
    }
};
```

## [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔 **交易。

**注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

> <pre><strong>输入：</strong>prices = [3,3,5,0,0,3,1,4]
> <strong>输出：</strong>6
> <strong>解释：</strong>在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
>      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</pre>

### 思路

区别于 买卖I（必须且仅交易一次），买卖II（必须但可交易1~n次），买卖III 规定至多买卖两次，因此**它是支持不买卖的**！

为了避免一个递增数组导致买卖次数超出两次，该问题的可选状态只能有五个：

* 0.还未操作
* 1.第一轮的持有股票状态
* 2.第一轮的未持有股票状态
* 3.第二轮的持有股票状态
* 4.第二轮的未持有股票状态

> 注意体会它跟买卖一二的状态差异：5种 (0~4) vs. 2种 (0&1)

1. **dp数组及其下标含义**：第`i`天在第`j`种状态下的最大资金为`dp[i][j]`，其中`j`为上述五种状态【0~4】
2. **递推公式**：可以看出这五种状态之间存在时间序列关系（因为题目仍要求仅能同时持有一次，必须先卖出才能下次买入），例如**第一次**到达状态`3`时，其上一个状态必定是`2`
   1. 状态`1`: ( a.沿用之前买入，b.今天买入) ：
      `max(dp[i - 1][1], dp[i - 1][0] - prices[i]);`
   2. 状态`2`: ( a.沿用之前卖出，b.今天卖出)：
      `max(dp[i - 1][2], dp[i - 1][1] - prices[i]);`
   3. 状态`3`: ( a.沿用之前买入，b.今天买入)：
      `max(dp[i - 1][3], dp[i - 1][2] - prices[i]);`
   4. 状态`4`: ( a.沿用之前卖出，b.今天卖出)：
      `max(dp[i - 1][4], dp[i - 1][3] - prices[i]);`
3. **数组初始化**：取决于第0天的五种状态
   1. 无操作：易得 `dp[0][0] = 0`
   2. 第一轮持有：开局就买入`dp[0][1] = -price[0]`
   3. 第一轮未持有，第二轮持有/未持有：只不过是左右倒手，反复买卖：
      `dp[0][2] = dp[0][4] = 0;` `dp[0][3] = dp[0][1] = -price[0]`
4. **遍历顺序**：同理为从前向后
5. **举例推导**：以一个递增数列[1,2,3,4,5]为例：
   ![](https://s3.bmp.ovh/imgs/2024/08/27/889207a2990e337c.png)

### 代码实现

```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int size = prices.size();
        
        vector<vector<int>>dp(size, vector<int>(5,0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];

        for(int i=1; i<size; i++){
            dp[i][0] = dp[i-1][0];
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]);
            dp[i][2] = max(dp[i-1][2], dp[i-1][1]+prices[i]);
            dp[i][3] = max(dp[i-1][3], dp[i-1][2]-prices[i]);
            dp[i][4] = max(dp[i-1][4], dp[i-1][3]+prices[i]);
        }

        return dp[size-1][4];
    }
};
```

### 后记

股票买卖问题的核心还是在于状态的分解，本组题目限定可选且仅能持有一支股票，因此每个时刻的可选状态都能够划分为一个有限集合（是否持有？顺沿持有还是当天购入持有？），此时只要确定好初始状态，自`i-1`向`i`逐步推算即可

### 参考

- 代码随想录：[https://www.programmercarl.com/](https://www.programmercarl.com/)
- OI Wiki：[https://oi-wiki.org/ds/](https://oi-wiki.org/ds/)
- [Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)
