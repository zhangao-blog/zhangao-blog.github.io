---
layout:     post
title:      0709算法 - 哈希表02
subtitle:   454.四数相加II | 383. 赎金信 | 15. 三数之和 | 18. 四数之和 
date:       2024-07-09
author:     ZA
header-img: img/algorithm.png
catalog: true
tags:
    - 算法笔记
    - 哈希表
---

## 前言

xxx

## [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

* `0 <= i, j, k, l < n`
* `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

### 思路

- 本质上是在`c，d`中找`0-(c+d)`是否在`a，b`中出现过？→ **哈希法**
- 要返回的元素有两个：1.差值`0-(c+d)`； 2.“有多少个”；→ **用map**
  `a+b` 的值作为快速查找的`key`，统计出现数目记录在`value`；

### 重点

* 对于`map[2]`，其中`2`代表`key`，返回结果代表`value`；

### 代码实现

```
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int, int> map;
        for(int a: nums1){
            for(int b : nums2){
                map[a+b]++;
            }
        }

        int count = 0;
        for(int c: nums3){
            for(int d: nums4){
                if(map.find(0-(c+d)) != map.end()){
                    count += map[0-(c+d)];
                }
            }
        }
        return count;
    }
};
```

## [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

`ransomNote` 和 `magazine` 由小写英文字母组成。

### 思路

- 更宽松的单向字母异位词问题，且只包含小写 → `int a[26] = {0};`
- 要分清谁提供字符(`hash++`)、谁构成字符(`hash--`)

### 代码实现

```
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        for(int i=0; i<magazine.length(); i++){
            record[magazine[i] - 'a']++;
        }

        for(int j=0; j<ransomNote.length(); j++){
            record[ransomNote[j] - 'a']--;
        }

        for(int k=0; k<26; k++){
            if (record[k]<0){
                return false;
            }
        }
        return true;
    }
};
```

## [15. 三数之和](https://leetcode.cn/problems/3sum/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：** 答案中不可以包含重复的三元组。

### 难点

- ~~想到用`map`保存`a+b`，然后用`0-c`来查找，但涉及到的信息包括搜索值`a+b`、以及`a, b, c`元素本身，`map`根本存不下！~~
- PS：**↑↑↑伪问题**！你保存`c`查找`0-(a+b)`不就行了，困难的根本原因是在于“三元组不可以重复”，这就需要再利用`vector`做去重。

### 思路

* 因为返回的是元素而不是下标，因此可以先 **排序** 以便于查找。
* 本题的核心在于 **去重** ，
* 需要理解本题的不重复，是指最后的结果数组之间不重复，组内重复是可以的，比如`[0,0,0]`, `[-1,-1,2]`👍√

    ![](https://s3.bmp.ovh/imgs/2024/07/10/de9579e177f30385.gif)

### 代码实现

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;

        for(int i=0; i<nums.size(); i++){
            if(nums[i]>0){
                return result;  // 最小的元素都已经大于0了
            }

            // 对 a 去重，但必须是nums[i-1]，i+1代表元素b，而组内是可以重复的
            if(i>0 && nums[i]==nums[i-1]) continue;  
            
            int left = i+1;
            int right = nums.size()-1;
            
            while(left<right){
                int sum = nums[i] + nums[left] + nums[right];
                if(sum>0) right--;
                else if(sum<0) left++;
                else{
                    result.push_back(vector<int>{nums[i],nums[left],nums[right]});
                    // a是固定的，只能跟自己过去路径上的i-1去重
                    // b,c是移动的，i+1是它们的未来路径，因此b就可以对i+1进行去重
                    while(left<right && nums[left]==nums[left+1]) left++;
                    while(left<right && nums[right]==nums[right-1]) right--;
                    left++;
                    right--;
                }
            } 
        }
        return result;  
    }
};
```

## [15. 三数之和](https://leetcode.cn/problems/3sum/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：** 答案中不可以包含重复的三元组。

### 难点

- ~~想到用`map`保存`a+b`，然后用`0-c`来查找，但涉及到的信息包括搜索值`a+b`、以及`a, b, c`元素本身，`map`根本存不下！~~
- PS：**↑↑↑伪问题**！你保存`c`查找`0-(a+b)`不就行了，困难的根本原因是在于“三元组不可以重复”，这就需要再利用`vector`做去重。

### 思路

* 因为返回的是元素而不是下标，因此可以先 **排序** 以便于查找。
* 本题的核心在于 **去重** ，
* 需要理解本题的不重复，是指最后的结果数组之间不重复，组内重复是可以的，比如`[0,0,0]`, `[-1,-1,2]`👍√
  
  ![](https://img.tditor.com/image-4ef07c4fc8524640b728fc7261b235a0.png)
  
  ![15. 三数之和](https://img.tditor.com/image-4ef07c4fc8524640b728fc7261b235a0.png)

### 代码实现

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;

        for(int i=0; i<nums.size(); i++){
            if(nums[i]>0){
                return result;  // 最小的元素都已经大于0了
            }

            // 对 a 去重，但必须是nums[i-1]，i+1代表元素b，而组内是可以重复的
            if(i>0 && nums[i]==nums[i-1]) continue;  
            
            int left = i+1;
            int right = nums.size()-1;
            
            while(left<right){
                int sum = nums[i] + nums[left] + nums[right];
                if(sum>0) right--;
                else if(sum<0) left++;
                else{
                    result.push_back(vector<int>{nums[i],nums[left],nums[right]});
                    // a是固定的，只能跟自己过去路径上的i-1去重
                    // b,c是移动的，i+1是它们的未来路径，因此b就可以对i+1进行去重
                    while(left<right && nums[left]==nums[left+1]) left++;
                    while(left<right && nums[right]==nums[right-1]) right--;
                    left++;
                    right--;
                }
            } 
        }
        return result;  
    }
};
```

## 后记

* 数组实现简单（直接下表索引），但处理问题规模也简单（处理稀疏问题浪费大量空间）
* set实现复杂（每次存储都要**映射+碰撞**），但能处理更复杂的问题（不定长、不重复、无序）

### 参考

- 代码随想录：[https://www.programmercarl.com/](https://www.programmercarl.com/)
- OI Wiki：[https://oi-wiki.org/ds/](https://oi-wiki.org/ds/)
- [Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)
