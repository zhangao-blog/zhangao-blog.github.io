---
layout:     post
title:      0805算法 - 动态规划03
subtitle:    01背包问题基础 | 416. 分割等和子集
date:       2024-08-05
author:     ZA
header-img: img/algorithm.png
catalog: true
tags:
    - 算法记录
    - 动态规划
---

## 背包问题基础

背包问题用于求解有限背包容量下，装入物品的最大价值，并根据每件物品的数量划分为01背包、完全背包、多重背包等多种问题，其框架如下：

![416.分割等和子集1](https://img.tditor.com/image-4ef07c4fc8524640b728fc7261b235a0.png)

### 01背包问题

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。 **每件物品只能用一次** ，求解将哪些物品装入背包里物品价值总和最大。

**暴力解法**：每件物品本质上只有 装 与 不装 两种选择，因此完整遍历n个物品以搜索出所有情况，表现为一个满二叉树，时间复杂度为O(2^n)

因此需要动态规划方法来避免这种指数级别的时间复杂度：

##### 1. **dp数组及其下标含义**：

为了同时考虑 物品价值 和 背包容量 两个维度，需要使用二维数组。此时，`dp[i][j]`表示任取下标为`[0-i]`的物品，放进容量为`j`的背包，最大的价值总和：
![](https://img.tditor.com/image-4ef07c4fc8524640b728fc7261b235a0.png)
以一组物品为例

| 编号 | 重量 | 价值 |
| --- | --- | --- |
| 物品0 | 1    | 15 |
| 物品1 | 3    | 20 |
| 物品2 | 4    | 30 |

首先考虑仅将物品0放入背包，即`dp[0][j]`

![](https://img.tditor.com/image-4ef07c4fc8524640b728fc7261b235a0.png)

> 容量为0时放不下，自容量1开始，仅放物品0的价值均为15

接下来考虑包含物品0和物品1的情况，即`dp[1][j]`
![](https://img.tditor.com/image-4ef07c4fc8524640b728fc7261b235a0.png)

> 容量为0时放不下，自容量1开始放入物品0，当容量3时可以放入价值更大的物品1，并在重量4全部放入

更好理解得，`dp[1][4]`表示从物品0、1中任取放入容量为4的背包，最大价值为35

##### 2. **递推公式**：

##### 3. **数组初始化**：

##### 4. **遍历顺序**：

##### 5. **举例推导**：

## [509. 斐波那契数](https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html)

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

### 思路

按照动规解题步骤：

1. **dp数组及其下标含义**：数`n`的斐波那契数值为`F(n)`
2. **递推公式**：题中已给出 `dp[i] = dp[i-1] + dp[i-2]`
3. **数组初始化**：题中已给出 `dp[0]=0; dp[1]=1;`
4. **遍历顺序**：根据公式，状态`i`依赖于状态`i-1`和`i-2`，因此从小到大遍历
5. **举例推导**：手算即可得[0,10]的斐波那契数列为 "0 1 1 2 3 5 8 13 21 34 55"

### 代码实现

不难想到完整计算出到目标数`n`的斐波那契数列，随后直接输出即可
时间复杂度：$O(n)$，空间复杂度：$O(n)$

```
class Solution {
public:
    int fib(int n) {
        if(n<=1) return n;
        vector<int> dp(n+1);  //容器长度为n+1
        dp[0] = 0;
        dp[1] = 1; 
        for(int i=2; i<=n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```

但实际上，计算目标数`k`的斐波那契值，只需要保存`k-1`和`k-2`即可
时间复杂度：$O(n)$，空间复杂度：$O(1)$

```
class Solution {
public:
    int fib(int n) {
        if(n<=1) return n;
        int dp[2];   // 数组大小为2
        dp[0] = 0;
        dp[1] = 1;
        for(int i=2; i<=n; i++){
            int sum = dp[0]+dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
};
```

## [70. 爬楼梯](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

规定`1 <= n <= 45`

**示例 ：**

<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>2
<strong>解释：</strong>有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶</pre>

### 思路

按照动规解题步骤：

1. **dp数组及其下标含义**：`n`阶台阶的爬法共有`dp[n]`种
2. **递推公式**：对于`n`阶最终只有两种情况，已爬到`n-1`阶，再爬一阶；已爬到`n-2`阶，再爬两阶。因此本阶爬法是下两阶爬法之和`dp[n] = dp[n-1] + dp[n-2]`
3. **数组初始化**：已知`n>=1`，定义`dp[1]=1; dp[2]=2;`
4. **遍历顺序**：上台阶的遍历顺序一定是从前向后遍历的
5. **举例推导**：手写出一个5阶台阶的推导结果串为“1, 2,  3, 5, 8”

问题：

* 对于第n阶的爬法F(n)，最终只有两种情况，已爬到n-1阶，再爬一阶；已爬到n-2阶，再爬两阶，那么能否F(n)=F(n-1)+F(n-2)？问题在于`F(n-1) & F(n-2)`有没有重复项。

> 伪命题，最终结果都不一样，过程怎么可能存在完全一样
> 而且就算前面爬的都一样，最后一步也必定是一个不同的 1 或 2：
> [1,1,1] + 2 vs. [1,1,1,1] + 1

### 代码实现

```
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n+2); // 为避免dp[2]出现空指针，也可以直接对初始值 return n 处理
        dp[1]=1;
        dp[2]=2;
        for(int i=3; i<=n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```

与斐波那契数列问题本质相同，因此也可以做出空间优化

```
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n; // 针对n=1打的补丁
        int dp[3];
        dp[1]=1;
        dp[2]=2;
        for(int i=3; i<=n; i++){
            int sum = dp[1]+dp[2];
            dp[1] = dp[2];
            dp[2] = sum;
        }
        return dp[2];
    }
};
```

## [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**示例 1：**

<pre><strong>输入：</strong>cost = [10,<em><strong>15</strong></em>,20]
<strong>输出：</strong>15
<strong>解释：</strong>你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。</pre>

### 思路

按照动规解题步骤：

1. **dp数组及其下标含义**：到达 `i` 阶的最小花费为 `dp[i]`
2. **递推公式**：可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]。

* dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。
* dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。
* 因此最小花费为：`dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);`

3. **数组初始化**：初始楼梯任选即`dp[0]=0; dp[1]=0;`
4. **遍历顺序**：爬楼梯的遍历顺序一定是从前向后遍历的
5. **举例推导**：

### 代码实现

```
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size()+1);
        dp[0]=0;
        dp[1]=0;
        for(int i=2; i<=cost.size(); i++){
            dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]);
        }
        return dp[cost.size()];
    }
};
```

### 后记

动态规划的核心在于递推公式的设计，它是循环体的主要部分；

此外，数组初始化决定了循环前dp数组的初值和长度、dp数组及其下标含义+遍历顺序共同决定了循环条件的设计。

### 参考

- 代码随想录：[https://www.programmercarl.com/](https://www.programmercarl.com/)
- OI Wiki：[https://oi-wiki.org/ds/](https://oi-wiki.org/ds/)
- [Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)
